# HW7 (Scala) - FP (Concurrent)

## Факторизация чисел

### Дан следующий фрагмент кода

```scala
package application

import cats.effect.std.Console
import cats.effect.{Concurrent, ExitCode, IO, IOApp}

object Application extends IOApp {

  override def run(args: List[String]): IO[ExitCode] =
    application[IO](args.flatMap(_.toLongOption), 5).attempt
      .map {
        case Left(_) => ExitCode.Error
        case Right(_) => ExitCode.Success
      }

  // Разрешается менять context bound функции
  def application[F[_] : Concurrent : Console](nums: List[Long], n: Int): F[Unit] = ???
  // Предлагается использовать parTraverseN, и какой-либо примитив синхронизации для пронумерованного вывода в консоль
}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;

### Задание

Программе подаётся список чисел и число `n`. Необходимо посчитать факторизацию (факторизация числа - разложение числа
на произведение его простых множителей) для каждого числа в списке и вывести в консоль в том порядке в котором они были
обработаны (т.е. порядок вывода может не совпадать с исходным порядком чисел в списке). Обработка чисел должна
происходить в `n` потоков. Вывод в консоль должен происходить конкурентно. Вывод в консоль не должен блокироваться
обработкой соседних чисел (т.е. если для факторизации числа `a` требуется `10s`, а для `b` требуется `1s` и исходный
список `a, b, b` и потоков > 1, то вывод для `b` должен быть напечатан сразу раньше чем для `a` - сразу после
обработки `b`)

### Формат:

* Простые множители записываем от меньшего к большему;
* Если число меньше нуля - добавляем множитель `-1` и обрабатываем как натуральное;
* Каждая строка вывод должна быть инкрементально пронумерована сквозной нумерацией с `1`;

Не забудьте написать тесты. Так же в данном дз необходимо будет выполнить ревью сокурсника.

### Пример:

#### Input:

`[100, -17, 25, 38]` `N = 4`

#### Output:

```text
line 1, -17 = -1 * 17
line 2, 25 = 5 * 5
line 3, 100 = 2 * 2 * 5 * 5
line 4, 38 = 2 * 19
```

### StyleCode:

* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты;
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (Используйте `Scala` коллекции);
* Использовать `mutable` коллекции запрещается (используйте `Ref` если требуется);
* Использовать `var` запрещается (используйте `Ref` если требуется);
* Использование `this` запрещается (используйте `self` если требуется);
* Использование `return` запрещается;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, методы `Monad`, `fold`);
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);

### Как сдавать (обратите внимание - процесс изменился):

* Сделайте fork репозитория `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/scala/hw7` (через интерфейс gitlab)
  в `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/students/<your-handle>/scala/hw7`;
* В качестве родительской ветки для решения используйте ветку `master` (**важно!**);
* Добавьте ваше решение в ветку `hw`;
* Открыть _Merge request_ из ветки `hw` в ветку `master` **upstream репозитория** (обратите внимание - ваш код будет
  доступен другим студентам);
* Дождаться когда пайплайн станет зелёным;
* (_Обязательный пункт_) **Выполните ревью сокурсника**, за хорошее ревью будут доп баллы;
* После дедлайна будут выложены тесты, вам потребуется нажать `rebase` в Merge request (через интерфейс gitlab), после
  чего тесты в вашей ветке обновятся;
* После успешного прохождения тестов (pipeline станет зелёным) работа считается сданной;
* (_Бонусный пункт_) Наилучшее решение (если таковое будет) будет замёржено в ветку `master` upstream репозитория и
  будет считаться референсным; автору решения будет доп балл;
* Если будут вопросы по времени сдачи дз - мы будем ориентироваться на время последнего вашего действия в _Merge
  request_.
