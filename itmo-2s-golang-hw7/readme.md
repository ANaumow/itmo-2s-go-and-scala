# HW7 (Golang) - Concurrency factorization

## Конкурентная факоризация чисел

### Дан следующий фрагмент кода

`pkg/fact/fact.go`

```golang
package fact

import "io"

type Input interface {
  N() int       // n - число горутин
  Slice() []int // слайс чисел, которые необходимо факторизовать
}

type Factorization interface {
  Work(input Input, io.Writer) error
}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;


### Задание

Программе подаётся список чисел и число `n`. Необходимо посчитать факторизацию (факторизация числа - разложение числа
на произведение его простых множителей) для каждого числа в списке и вывести в консоль в том порядке в котором они были
обработаны (т.е. порядок вывода может не совпадать с исходным порядком чисел в списке). Обработка чисел должна
происходить в `n` потоков. Вывод в консоль должен происходить конкурентно. Вывод в консоль не должен блокироваться
обработкой соседних чисел (т.е. если для факторизации числа `a` требуется `10s`, а для `b` требуется `1s` и исходный
список `a, b, b` и потоков > 1, то вывод для `b` должен быть напечатан сразу раньше чем для `a` - сразу после
обработки `b`)

### Формат:

* Простые множители записываем от меньшего к большему;
* Если число меньше нуля - добавляем множитель `-1` и обрабатываем как натуральное;
* Каждая строка вывод должна быть инкрементально пронумерована сквозной нумерацией с `1`;

Не забудьте написать тесты. Так же в данном дз необходимо будет выполнить ревью сокурсника.

### Пример:

#### Input:

`[100, -17, 25, 38], 3`

#### Output:
```text
line 1, 100 = 2 * 2 * 5 * 5
line 2, -17 = -1 * 17
line 3, 38 = 2 * 19
line 4, 25 = 5 * 5
```
Пояснение: номер линии и факторизация



### Как сдавать:

* Сделайте fork репозитория `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/golang/hw7` (через интерфейс gitlab)
в `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/students/<your-handle>/golang/hw7`;
* Добавьте ваше решение в ветку `hw`;
* Открыть _Merge request_ из ветки `hw` в ветку `master` **upstream репозитория** (обратите внимание - ваш код будет
    доступен другим студентам);

* Дождаться когда пайплайн станет зелёным;
* (_Обязательный пункт_) **Выполните ревью сокурсника**, за хорошее ревью будут доп баллы;
* После дедлайна будут выложены тесты, потребуется подтянуть изменения из `upstream` репозитория,
    сделать `rebase` в Merge Request (через интерфейс gitlab), и запушить изменения в ваш репозиторий (если вы всё сделали правильно, новые тесты
    автоматически запустятся на CI);
* После успешного прохождения тестов (pipeline станет зелёным) работа считается сданной;
* (_Бонусный пункт_) Наилучшее решение (если таковое будет) будет замёржено в ветку `master` upstream репозитория и
    будет считаться референсным; автору решения будет доп балл;
* Если будут вопросы по времени сдачи дз - мы будем ориентироваться на время последнего вашего действия в _Merge
    request_.

