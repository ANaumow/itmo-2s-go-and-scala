# HW6 (Scala) - FP (Effect)

## Играемся с эффектами

### Дан следующие описания тайплкласов `Env` и `LocalEnv`

```scala
package env

trait Env[F[_]] {
  def find(key: String): F[Option[String]]
}

// Разрешается менять context bound функций
object Env {
  def apply[F[_]](implicit env: Env[F]): Env[F] = env

  def stub[F[_]]: Env[F] = ???

  def fromMap[F[_]](context: Map[String, String]): Env[F] = ???

  implicit def system[F[_]]: Env[F] = ???
}
```

```scala
package env

trait LocalEnv[F[_]] extends Env[F] {
  def set(key: String, value: String): F[Unit]
}

// Разрешается менять context bound функций
object LocalEnv {
  def apply[F[_]](implicit env: LocalEnv[F]): LocalEnv[F] = env

  implicit def fromEnv[F[_] : Env]: LocalEnv[F] = ???
}

```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;

### Задание

В предыдущем дз вы попробовали написать свой тайпкласс `Env`, в этом дз требуется его доработать, а так же добавить
новый тайпкласс `LocalEnv`:

* `Env` умеет только возвращать переменные окружения, имеет три метода конструктора:
    * `stub` - всегда возвращает `"scala"`;
    * `fromMap` - создаёт тайпкласс который возвращает значения из переданной `Map`;
    * `system` - использует настоящие переменные окружения;
* `LocalEnv` - расширяет функционал для `Env`:
    * `set` - задаёт значение переменной окружения для запущенного приложения;

* `main` класс `Application` имеет метод для запуска:
    * `application` - бесконечный цикл взаимодействия с пользователем, доступные команды пользователю:
        * `exit` - выйти и успешно завершить программу;
        * `set <key> <value>` - установить переменную окружения (локального);
        * `get <key>` - получить переменную окружения;

Уточнения:

* Если переменная уже существует, `set` должен обновлять значение;
* Реализации `Env` не видят изменений заданные через `set` (их видят только реализации `LocalEnv`);
* **Устанавливать и менять переменные окружения запрещено** (можно только получать).

Пример взаимодействия с пользователем:

```text
> get HTTP_PORT
< None
> set HTTP_PORT 8080
< HTTP_PORT 8080
> get HTTP_PORT
< 8080
> set HTTP_PORT  80
< HTTP_PORT 80
> get HTTP_PORT
< 80
> exit
```

**PS**:

* Данное задание подразумевает использование тайпклассов: `Console, Ref, Concurrent`;
* Возможно вы захотите добавить новый тайпкласс `EnvStorage` (для хранения переменных окружения);
* Для использования синтаксиса сделайте нужный импорт `import cats.implicits.*` (вместо `*` выберете нужный);
* Для использования `flatMap` и `map` не забудьте добавить `import cats.implicits.toFlatMapOps`
  и `import cats.implicits.toFunctorOps`;

### StyleCode (обратите внимание - есть обновления):

* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты;
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (Используйте `Scala` коллекции);
* Использовать `mutable` коллекции запрещается (используйте `Ref` если требуется);
* Использовать `var` запрещается (используйте `Ref` если требуется);
* Использование `this` запрещается (используйте `self` если требуется);
* Использование `return` запрещается;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, методы `Monad`, `fold`);
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);

### Как сдавать (обратите внимание - процесс изменился):

* Сделайте fork репозитория `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/scala/hw6` (через интерфейс gitlab)
  в `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/students/<your-handle>/scala/hw6`;
* В качестве родительской ветки для решения используйте ветку `tests` (**важно!**);
* Добавьте ваше решение в ветку `hw`;
* Открыть _Merge request_ из ветки `hw` в ветку `tests` **upstream репозитория** (обратите внимание - ваш код будет
  доступен другим студентам);
* Дождаться когда пайплайн станет зелёным, после этого можно назначить в ревьюеры _Merge request_ `@geny200`;
* (_Бонусный пункт_) Выполните ревью сокурсника, за хорошее ревью будут доп баллы;
* После дедлайна будут выложены тесты, вам потребуется нажать `rebase` в Merge request (через интерфейс gitlab), после
  чего тесты в вашей ветке обновятся;
* После успешного прохождения тестов (pipeline станет зелёным) работа считается сданной;
* (_Бонусный пункт_) Наилучшее решение (если таковое будет) будет замёржено в ветку `tests` upstream репозитория и
  будет считаться референсным; автору решения будет доп балл;
* Если будут вопросы по времени сдачи дз - мы будем ориентироваться на время последнего вашего действия в _Merge
  request_.
