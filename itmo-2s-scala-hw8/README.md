# HW8 (Scala) - FP (Concurrent)

## Сервис доставки

### Задание

#### Кейс

У вас есть сервис по доставке продуктов из магазинов (магазины не подключены к вашей партнёрской сети, и для оплаты
заказа нужно платить на кассе магазина). В компании работает более 100_000 курьеров по всей стране.
Сейчас клиент может сделать заказ через приложение, после чего будет выбран ближайший курьер и ему на карте (для каждого
курьера выпущена банковская карта с доступом к общему счёту) будет установлен лимит на расход равный стоимости заказа
для выкупа из магазина. Вам потребовалось добавить новую фичу - добавить для клиента возможность отменить заказа до
того, как он начнёт собираться. Вы решили начать с сервиса по установке лимитов для банковских карт курьеров.

Вам требуется модифицировать код сервиса:

* Добавить параллельное исполнение запросов к банку (не более чем `N` параллельных запросов);
* Добавить возможность отмены запросов;

#### Старый код сервиса

У вас уже имеется код, который может последовательно обрабатывать установку лимитов.

```scala
package application

import bank.{BusinessLimitBank, LagBusinessLimitBank}
import cats.Monad
import cats.effect.std.{Console, Random}
import cats.effect.{Async, ExitCode, IO, IOApp}
import cats.implicits.{catsSyntaxFlatMapOps, toFlatMapOps, toFunctorOps}

import scala.util.matching.Regex

object Application extends IOApp {

  // Запрещается менять
  override def run(args: List[String]): IO[ExitCode] =
    service[IO].attempt
      .map {
        case Left(_) => ExitCode.Error
        case Right(_) => ExitCode.Success
      }

  // Разрешается менять
  private def service[F[_] : Async : Console]: F[Unit] =
    Random
      .scalaUtilRandomSeedInt[F](42)
      .map { implicit random => LagBusinessLimitBank[F](5) }
      .flatMap(application(_, 5))

  // Разрешается менять context bound функции
  def application[F[_] : Monad : Console](bank: BusinessLimitBank[F], maxConnections: Int): F[Unit] =
    Monad[F].foreverM {
      Console[F].readLine.flatMap {
        case set(id, amount) => bank.setLimit(id, amount) >> Console[F].println(s"set $id $amount")
        case command => Console[F].println(s"Unknown command '$command'")
      }
    }

  private val set: Regex = raw"set\s+(\d{10})\s+(\d+)".r
  private val cancel: Regex = raw"cancel\s+(\d{10})".r // Не используется
}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;

#### Команды:

* `set <id> <amount>` - Увеличить лимит по карте с идентификатором `id` на сумму `amount`
* `cancel <id>` - Отменить установку лимита по карте с идентификатором `id`

#### Интерфейс банка

У вас есть интерфейс для работы с банком:

```scala
trait BusinessLimitBank[F[_]] {
  def setLimit(id: String, amount: String): F[Unit]

  def getLimit(id: String): F[Int]
}
```

Операции `setLimit` и `getLimit` выполняются за какое-то конечное время; Можете использовать
класс `LagBusinessLimitBank` для имитации задержек по сети.

#### Ограничения

* К банку одновременно может быть не более `N` обращений;
* Операции ввода и вывода не должны блокировать:
    * Логика сервиса не должна блокировать операции ввода;
    * Операции вывода не должны блокировать логику сервиса (операция вывода может заблокироваться на некоторое время);
* `cancel` должен отменять исполнение уже имеющегося запроса к банку с переданным `id` (если таковой запрос ещё
  исполняется);
* (дополнительно - доп балл) На сигнал `SIGTERM` ваш сервис должен поддерживать graceful shutdown (перестать принимать
  новые команды, завершить обработку текущих, высвободить ресурсы и успешно завершиться)

#### Гарантии

* Банк всегда отвечает за конечное время;
* Лимит карты до вызова любой операции `set` всегда 0;
* Пока не закончится обработка команды `set` с id карты - не может прийти вторая команда `set` с тем же id;
* Прерывание операции `setLimit` - не гарантирует что лимит будет откачен в 0;
* Прерывание операции `setLimit` и последующая установка лимита в 0 - в результате всегда дадут установленный лимит в 0;

### Пример:

`N` = 3 (максимальное количество параллельно исполняемых запросов к банку)

```text
> set 0123456789 2300
> set 1234567890 5600
< set 1234567890 5600
> set   1234567890   5600
< set 1234567890 5600
> sdr 
< set 0123456789 2300
< Unknown command 'sdr '
> set 1111111111 1111
> set 2222222222 2222
> set 3333333333 3333
> cancel 1111111111
< cancel 1111111111
> set 4444444444 1234
> cancel 3333333333
< set 2222222222 2222
> cancel 4444444444
< set 4444444444 1234
< cancel 3333333333
< cancel 4444444444
```


```text
=> set 0 2300 устанавливаем 
=> set 1 5600 устанавливаем
< set 1 5600 установилось
=> set   1   5600 меняем уже установленное
< set 1 5600 установилось
=> sdr вводим чушь
< set 0 2300 только что закончилось, типо все не так быстро
< Unknown command 'sdr ' 
=> set 11 1111 
=> set 22 2222
=> set 33 3333
=> cancel 11 отменяем еще не установившиеся
< cancel 11 не законченная установка отменилась нормально
=> set 44 1234 
=> cancel 33 
< set 22 2222
=> cancel 44
< set 44 1234 так а вот это интересно, оно все равно установилось не смотря на команду
< cancel 33
< cancel 44 но потом все равно отменилось
```

Пояснение:

* `cancel` для операции которая уже завершилась = установка лимита в `0` для карты с переданным `id`;
  пример `cancel 4444444444`;
* `cancel` при уже достигнутом лимите на параллельное исполнение запросов к банку, должен отменить исполнение запроса
  к банку с переданным id (если таковой запрос ещё исполняется); пример `cancel 1111111111`;
* Вывод результата исполнения операции происходит после выполнения операции (исходный порядок не сохраняется);

### План по итеративному изменению сервиса

Вы отдали задание на проработку изменения сервиса фрилансеру, он составил вам план (в нём есть допущения, и могут быть
ошибки):

* Для безопасного закрытия всех потоков в последующих пунктах - добавить `Supervisor`;
* Разделить потоки ввода/вывода и исполнения логики;
* Добавить параллельное исполнение запросов;
* Добавить обёртку (паттерн декоратор) над `BusinessLimitBank` для контроля количества параллельных соединений;
* Добавить механизм для отслеживания связи: "`id` карты - поток выполняющий операцию";
* Добавить возможность отмены потока по `id` карты;

### Тесты

##### Проверка ограничения на количество параллельно исполняемых запросов

`N` = 1 (максимальное количество параллельно исполняемых запросов к банку); банк кидает исключение если запросов больше
чем N.

```text
> set 1111111111 1111
> set 2222222222 2222
> set 3333333333 3333
< set 1111111111 1111
< set 2222222222 2222
< set 3333333333 3333
```

Последовательность вывода всегда одинаковая (если убрать операции ввода, то вывод всегда одинаковый).

##### Проверка отмены текущих запросов и не блокирующий ввод

`N` = 1 (максимальное количество параллельно исполняемых запросов к банку); время ответа банка на первые поступившие 2
запроса в банк - _1 год_, на последующие 2 запроса ответ моментальный;

```text
> set 0123456789 2300
> set 1234567890 5600
> cancel 0123456789
> cancel 1234567890
< cancel 0123456789
< cancel 1234567890
```

Вывод всегда одинаковый.

##### Проверка не блокирующего логику вывод

`N` = 1 (максимальное количество параллельно исполняемых запросов к банку); время ответа банка - моментально

```text
// консоль вывода заблокирована
> set 1111111111 1111
> set 2222222222 2222
> set 3333333333 3333
// ожидание что к банку будет исполнено 3 запроса (ждём пока счётчик запросов у банка будет равен 3)
// разблокируем вывод
< set 1111111111 1111
< set 2222222222 2222
< set 3333333333 3333
```

Вывод может быть в любой последовательности.

### StyleCode:

* Тест классы именуются `<ClassName>Test`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты;
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (Используйте `Scala` коллекции);
* Использовать `mutable` коллекции запрещается (используйте `Ref` если требуется);
* Использовать `var` запрещается (используйте `Ref` если требуется);
* Использование `this` запрещается (используйте `self` если требуется);
* Использование `return` запрещается;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, методы `Monad`, `fold`);
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);

### Как сдавать (обратите внимание - процесс изменился):

* Сделайте fork репозитория `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/scala/hw8` (через интерфейс gitlab)
  в `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/students/<your-handle>/scala/hw8`;
* В качестве родительской ветки для решения используйте ветку `master` (**важно!**);
* Добавьте ваше решение в ветку `hw`;
* Открыть _Merge request_ из ветки `hw` в ветку `master` **upstream репозитория** (обратите внимание - ваш код будет
  доступен другим студентам);
* Дождаться когда пайплайн станет зелёным;
* (_Обязательный пункт_) **Выполните ревью сокурсника**, за хорошее ревью будут доп баллы;
* После дедлайна будут выложены тесты, вам потребуется нажать `rebase` в Merge request (через интерфейс gitlab), после
  чего тесты в вашей ветке обновятся;
* После успешного прохождения тестов (pipeline станет зелёным) работа считается сданной;
* (_Бонусный пункт_) Наилучшее решение (если таковое будет) будет замёржено в ветку `master` upstream репозитория и
  будет считаться референсным; автору решения будет доп балл;
* Если будут вопросы по времени сдачи дз - мы будем ориентироваться на время последнего вашего действия в _Merge
  request_.


00000000000000000150
