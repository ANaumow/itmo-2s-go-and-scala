# HW3 (Scala) - Коллекции

## Часть 1 - Range

### Дан следующий фрагмент кода

`range/Range.scala`

```scala
package range

trait Range {
  def length: Int

  def intersect(other: Range): Range

  def union(other: Range): Option[Range]

  def isEmpty: Boolean

  def contains(i: Int): Boolean

  def contains(other: Range): Boolean

  def isIntersect(other: Range): Boolean

  def toList: List[Int]

  def minimum: Option[Int]

  def maximum: Option[Int]
}

// Для вычисление строкового представления интервала используйте
// override def toString: String = ???

object Range {
  def empty: Range = ???

  def fromInterval(min: Int, max: Int): Range = ???
}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;

### Задание

Реализуйте абстрактный тип данных `Range`, представляющий замкнутый целочисленный интервал. `Range` должен поддерживать
следующие операции:

* Конструирование:
    * Создание пустого интервала.
    * Создание интервала [min; max] по концевым точкам.
* Бинарные операции:
    * Пересечение интервалов.
    * Объединение пересекающихся интервалов.
* Унарные предикаты:
    * Проверка интервала на пустоту.
    * Проверка точки на вхождение в интервал.
* Бинарные предикаты:
    * Проверка двух интервалов на равенство.
    * Проверка двух интервалов на пересечение.
    * Проверка интервала на вхождение в другой.
* Прочее:
    * Перечисление всех точек интервала в порядке возрастания.
    * Вычисление минимума интервала.
    * Вычисление максимума интервала.
    * Вычисление строкового представления интервала, в формате `[-3; 7]`, для пустого используйте `∅`.

Напишите тесты покрывающие все методы.

## Часть 2 - Bank

### Дан следующий фрагмент кода

`bank/Account.scala`

```scala
package bank

import java.time.{Clock, LocalDateTime}

final case class Operation(time: LocalDateTime, amount: Int)

trait Account {
  def topUp(amount: Int): Option[Account]

  def withdraw(amount: Int): Option[Account]

  def operations: List[Operation]

  def statement: String

  def balance: Int
}

object Account {
  def createAccount(clock: Clock): Account = ???
}
```

Запрещается в приведённом фрагменте кода:

* Менять сигнатуры;
* Менять модификаторы доступа;
* Менять пакеты;

### Задание

Реализуйте абстрактный тип данных `Account`, представляющий модель банковского расчетного счета. Счет ведется в условных
единицах и не допускает достижения отрицательного баланса. `Account` должен поддерживать следующие операции:

* Внести средства на счет;
* Снять средства со счета;
* Сформировать выписку по счету;
* Получить текущий баланс;

Пример формата выписки:

```text
Time Amount Balance
28.09.2021 13:37:00 +500 500
28.09.2021 13:37:01 -100 400
```

Напишите тесты покрывающие все методы.

### StyleCode:

* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты;
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается;
* Использовать mutable коллекции запрещается;
* Использовать var запрещается.

### Как сдавать:

* Сделайте fork репозитория `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/scala/hw3` (через интерфейс gitlab)
  в `https://itmo-b.gitlab.yandexcloud.net/itmo-spring-2023/students/<your-handle>/scala/hw3`;
* В качестве родительской ветки для решения используйте ветку `tests` (**важно!**);
* Добавьте ваше решение в ветку `hw`;
* Открыть _Merge request_ из ветки `hw` в ветку `master`;
* Дождаться когда пайплайн станет зелёным, после этого можно назначить в ревьюеры _Merge request_ `@geny200`;
* `18.03.2023` на практике будут выложены тесты, потребуется подтянуть изменения из `upstream` репозитория,
  сделать `rebase` на ветку `tests`, и запушить изменения в ваш репозиторий (если вы всё сделали правильно, новые тесты
  автоматически запустятся на CI);
* После успешного прохождения тестов (pipeline станет зелёным) работа считается сданной;
* Если будут вопросы по времени сдачи дз - мы будем ориентироваться на время последнего вашего действия в _Merge
  request_.
